# Wytworzenie zbioru danych

## Pobranie danych
Dane użyte do analizy są podzielone na trzy zbiory nazwane “cve”, “crawl” oraz “bugsinpy”, które różnią się sposobem, w jaki zostały pozyskane dane. Wszystkie trzy zbiory zawierają dane na temat konkretnych błędów w kodach źródłowych różnych projektów programistycznych: identyfikator błędu (odpowiadający numerowi CVE w przypadku zbiorów cve i crawl) oraz jedną lub więcej migawek, w których naprawiono ów błąd (a konkretnie diffy tych migawek).

W tej pracy poprzez określenia “błąd” i “naprawa błędu” będzie rozumiane pojedyncze CVE ze zbioru cve lub crawl albo pojednyczy “bug” ze zbioru bugsinpy.

Pierwszy zbiór został zbudowany w oparciu o bazę danych NVD. Numery CVE zostały pozyskane przy użyciu oprogramowania CVE-Search. Następnie dla każdego numeru dane na temat CVE zostały pobrane w formacie JSON przy użyciu API CVE-Search i włączone do zbioru danych. Każdy plik JSON został przeszukany, aby znaleźć występujące w nim adresy URL. Jeżeli dany URL był adresem do commitu lub pull requestu na stronie GitHub lub BitBucket, przy użyciu API tych serwisów były pobierane i zapisywane w plikach dane: patch oraz opis commitu lub pull requestu.

Zbiór crawl został utworzony poprzez przeszukiwanie historii zmian w kodach źródłowych pewnych repozytoriów z serwisie GitHub pod kątem migawek dotyczących napraw CVE. Do zbioru włączane były migawki, których opis zawierał numer CVE.

Zbiór bugsinpy pochodzi bezpośrednio z pracy “BugsInPy: A Database of Existing Bugs in Python Programs to Enable Controlled Testing and Debugging Studies”. Podobnie jak poprzednie zawiera on naprawy błędów w kodzie Pythona, jednak nie dotyczy konkretnie CVE.

## Automatyczne oznaczenia

Dane ze zbiorów zostały wstępnie automatycznie oznaczone za pomocą specjalnie w tym celu opracowanych skryptów. Biblioteka PatchSet była używana do przetwarzania plików .diff, a lekser z biblioteki Pygments do wyznaczania tokenów z poszczególnych linijek kodu. Na podstawie pliku languages.yml z repozytorium Pygments oraz ścieżki pliku określano język używany w każdym ze zmienionych w patchu plików i na tej podstawie wyznaczano wstępnie kategorię pliku. Na podstawie kategorii pliku oraz tokenów występujących w linii kodu wstępnie wyznaczana była kategoria linii.

Sama ścieżka pliku w repozytorium może zawierać informacje na temat jego przeznaczenia. Skrypt automatycznie wyznaczający kategorie plików w pierwszej kolejności brał pod uwagę wzorce występujące w ścieżkach.
- Jeżeli ścieżka zawierała słowo “test”, plik był klasyfikowany do kategorii test. 
- Jeżeli ścieżka zawierała którąkolwiek z nazw związanych z zarządzaniem projektem, np. "makefile", "requirements.txt" lub "composer.json", plik był klasyfikowany do kategorii project.
- Jeżeli ścieżka zawierała którąkolwiek z fraz związanych z dokumentacją, tj. "doc", "docs", "documentation" lub "man", plik był klasyfikowany do kategorii documentation.

W następnej kolejności, jeżeli nie dało się zaklasyfikować pliku na podstawie ścieżki, skrypt brał pod uwagę rozszerzenie pliku. Plik languages.yml z biblioteki Pygments zawiera listę języków, z których każdy ma przypisany typ, czyli “data”, “programming”, “markup”, “prose” albo “nil”, oraz charakterystyczne dla niego rozszerzenia. Na przykład język programowania C ma typ “programming” i rozszerzenia ".c", ".cats", ".h", ".idc".

- Jeżeli rozszerzenie pasowało do języka typu “prose”, plik był klasyfikowany do kategorii documentation.
- Jeżeli rozszerzenie pasowało do języka typu "programming", "data" lub "markup", plik był klasyfikowany odpowiednio do programming, data lub markup.
- Jeżeli rozszerzenie nie pasowało do żadnego języka, plik był klasyfikowany do kategorii other.

Linie kodu były klasyfikowane na podstawie kategorii pliku oraz tokenów zwróconych przez lekser Pygments.

- Każda linia w plikach oznaczonych jako dokumentacja była klasyfikowana do kategorii documentation.
- Jeżeli linia zawierała tokeny klasy Comment, a poza nimi tylko ewentualnie Text oraz białe znaki, była klasyfikowana do kategorii documentation.
- Każda linia w plikach oznaczonych jako test, która nie była zaklasyfikowana do kategorii documentation, była klasyfikowana jako test.
- W pozostałych przypadkach, linia była klasyfikowana do kategorii bug(fix).

## Manualne oznaczenia

W procesie oznaczania brało udział sześciu annotatorów, z których każdy miał przynajmniej 4 lata doświadczenia z językiem Python. Wśród nich było trzech bardziej doświadczonych annotatorów (ekspertów) o ponad 10 latach doświadczenia.

Wszystkie zbiory zostały przejrzane przez w sumie sześciu annotatorów. Każdy pojedynczy błąd został ręcznie przejrzany i oznaczony przynajmniej przez trzech annotatorów, w tym jednego eksperta.

11 błędów w zbiorze zostało wyznaczonych jako wzorcowe adnotacje, które miały służyć za punkt odniesienia dla pozostałych oznaczeń. Oznaczenia te zostały ustalone wspólnie przez trzech annotatorów ekspertów.

Zadaniem annotatora było:
- przypisanie każdego pliku zmienionego w migawce do jednej z 7 kategorii,
- przypisanie każdej linijki zmienionej w migawce (zarówno w wersji pliku przed zmianą jak i po) do jednej z 7 kategorii,
- przypisanie błędu do jednej z 3 kategorii.

Pliki i linie miały automatycznie przypisane wstępne kategorie, ale finalnie każda musiała być przejrzana i zatwierdzona przez annotatora.

Wśród kategorii plików były 4 kategorie główne i 3 kategorie poboczne. W procesie oznaczania kategorie główne miały pierwszeństwo przed pobocznymi.

Kategorie główne plików to:
- project – pliki związane z zarządzaniem projektem
- programming – kod źródłowy
- tests – pliki używane do testów
- documentation – dowolna forma dokumentacji

Kategorie poboczne plików to:
- data – dane używane w projekcie
- markup – pliki w językach znaczników takich jak XML lub HTML
- other – wszystkie pliki niepasujące do pozostałych kategorii

Kategorie linii to:
- **bug(fix)** – linia zawierająca lub naprawiająca błąd
- **bug(fix) + refactoring** – linia naprawiająca błąd wraz z refaktoryzacją kodu
- **documentation** – dokumentacja, w szczególności komentarze w kodzie i linie z plików dokumentacji
- **test** – dodanie nowego testu, naprawa lub usunięcie starego testu
- **test + refactoring** – dodanie nowego testu, naprawa lub usunięcie starego testu wraz z refaktoryzacją kodu
- **refactoring** – refaktoryzacja, zmiany które nie wpływają na funkcjonowanie programu, tylko zmieniają strukturę kodu i poprawiają czytelność
- **other** – inny typ błędu, nowa funkcjonalność, jakiekolwiek zmiany niepasujące do pozostałych kategorii

Kategorie błędów to:
- core
- application/library
- other

Do procesu ręcznego oznaczania wykorzystano oprogramowanie diff2html służące do formatowania plików .diff oraz LabelStudio jako interfejs użytkownika.

![Diagram procesu wytwarzania zbioru danych](03_figures/img/data_set_creation.png)