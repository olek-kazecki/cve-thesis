# Preliminaria

W tej sekcji wprowadzę najważniejsze pojęcia związane z tą pracą. Wyjaśnię, czym jest git, jaki ma on związek z systemem CVE, jak użyłem obydwu systemów do przeprowadzenia analizy przeżycia oraz na czym ta analiza polega.

## Git

Git jest systemem kontroli wersji powszechnie używanym w środowisku programistycznym do śledzenia historii zmian w kodzie. Został stworzony w 2005 roku przez twórcę systemu operacyjnego Linux na potrzeby rozwoju jądra Linuksa.

Jest to jedno z podstawowych narzędzi w pracy programisty, pozwalające na szybkie zapisywanie, przeglądanie i przywracanie poszczególnych wersji danego oprogramowania w procesie jego rozwoju. Umożliwia również sprawną koordynację pracy przy projektach zespołowych. Ponieważ system jest rozproszony, każdy użytkownik może pracować na swojej, lokalnej kopii bez ingerowania w pracę innych członków zespołu. W przypadku projektów zespołowych, oprócz lokalnych kopii repozytorium na komputerze każdego użytkownika zwykle istnieje też jedno zdalne repozytorium.

To zdecydowanie najpopularniejsze oprogramowanie tego typu: wg ankiety przeprowadzonej przez StackOverflow w 2022 używało go 95% programistów. Najczęściej używanym interfejsem jest interfejs linii komend. Oprócz tego obsługę gita oferują różne zintegrowane środowiska programistyczne. Istnieją też dedykowane aplikacje z interfejsem graficznym.

Git operuje na repozytoriach. Repozytorium jest to struktura danych przechowująca metadane dla danego zbioru plików lub struktury katalogów. W przypadku zastosowania gita do procesu tworzenia oprogramowania, zwykle jedno repozytorium jest przeznaczone na jeden program, jak aplikacja komputerowa lub biblioteka.

Do zatwierdzania zmian w kodzie źródłowym służą tzw. migawki. Migawka (ang. commit) jest pojedynczym zapisem zmian wprowadzonych w plikach repozytorium. Każda migawka jest identyfikowana przez hasz – unikalny ciąg liter i cyfr.

Ważnym elementem systemu git jest mechanizm gałęzi. Gałąź (ang. branch) jest duplikatem konkretnej migawki z repozytorium, który może następnie być modyfikowany niezależnie od oryginału. Jest to szczególnie użyteczne w przypadku projektów zespołowych: pozwala na równoległą pracę nad repozytorium bez ingerowania w zmiany innych osób.

Popularnym serwisem hostingowym często używanym do zdalnego przechowywania repozytoriów gita jest GitHub założony w 2008 roku. W 2019 roku na GitHubie było umieszczonych 100 milionów repozytoriów.

GitHub udostępnia mechanizm tzw. pull requestów. Pull request to prośba użytkownika o scalenie gałęzi w zdalnym repozytorium. Jest to podstawowy sposób wprowadzania zmian do repozytoriów, przy których pracuje wiele osób. Programista tworzy gałąź w repozytorium lokalnym i na niej wprowadza pożądane zmiany. Następnie udostępnia gałąź w zdalnym repozytorium na GitHubie i tworzy pull request. Wtedy uprawniony do tego użytkownik może przejrzeć zmiany i jeżeli je zaakceptuje, zostaną one wcielone do gałęzi głównej.

Diff to narzędzie służące do znajdywania różnic między plikami. W gicie polecenie diff pozwala na porównanie dwóch wersji repozytorium. “Diffem” nazywamy też wynik polecenia diff. Diff danej migawki zawiera listę wprowadzonych w niej zmian.

Na poniższym rysunku znajduje się fragment przykładowego diffa w gicie.

![Fragment przykładowego diffa](03_figures/img/diff.png)

Pierwsza linijka zawiera polecenie diff użyte do porównania dwóch plików. Widzimy, że ścieżki plików są takie same z wyjątkiem liter “a” i “b” na początku. Oznacza to, że są porównywane dwie wersje tego samego pliku i ścieżka pliku nie zmieniła się, więc plik nie został przeniesiony ani jego nazwa nie została zmieniona.

W drugiej linijce wypisane są początkowe znaki dwóch haszy migawek gita. Daje to informację o tym, jakie migawki są ze sobą porównywane.

Linijki trzecia i czwarta podają nazwy porównywanych plików. Ponieważ porównujemy ten sam plik, stara wersja pliku jest oznaczona znakami “-” i literą “a”, a nowa – znakami “+” i literą “b”.

Piąta linijka podaje informację o miejscu w pliku, z którego pochodzi niżej wypisany fragment kodu. Mamy tam podany ciąg czterech liczb. “-359,11” oznacza, że w pierwszej wersji pliku ten fragment zaczynał się w linijce 359. i zajmował 11 linijek.  “-359,11” oznacza, że w drugiej wersji pliku ten fragment zaczynał się też w linijce 359. i zajmował 12 linijek. Dalej w tej samej linijce jest wypisana funkcja, w której wprowadzono zmiany.

Dalsza część diffa widoczna na rysunku to już treść samego pliku. Jeśli dana linijka jest poprzedzona spacją, oznacza to, że jest obecna w obydwu wersjach pliku. Linijki zaczynające się od znaku “-”, to linijki, które były obecne tylko w pierwszej wersji, zostały więc usunięte. Linijki zaczynające się od “+” znalazły się tylko w drugiej wersji pliku, czyli zostały dodane.

Z tych informacji można odtworzyć obydwie wersje pliku. Wiemy, że ten fragment w pierwszej wersji wyglądał tak
```
}

/* All zeroes == unconditional rule. */
static inline bool unconditional(const struct arpt_arp *arp)
{
	static const struct arpt_arp uncond;

	return memcmp(arp, &uncond, sizeof(uncond)) == 0;
```
Zaś w drugiej wersji tak:
```
}

/* All zeroes == unconditional rule. */
static inline bool unconditional(const struct arpt_entry *e)
{
	static const struct arpt_arp uncond;

	return e->target_offset == sizeof(struct arpt_entry) &&
```
Polecenie blame pozwala dla każdej linijki pliku sprawdzić, w jakiej migawce po raz pierwszy dana linijka się pojawiła. To samo polecenie z opcją --reverse pokazuje z kolei, w której migawce linia pojawiła się po raz ostatni.

## CVE
CVE (Common Vulnerabilities and Exposures) to system dokumentowania znanych luk bezpieczeństwa w systemach informatycznych. Jest utrzymywany przez amerykańską organizację MITRE, a lista wszystkich przypadków jest przechowywana w publicznie dostępnej bazie danych National Vulnerability Database (NVD). Skrótem “CVE” określa się też pojedyncze wpisy w systemie CVE.

Każde CVE ma przypisany unikalny identyfikator oraz punktację w skali 0-10 określającą, jak poważne stanowi zagrożenie dla bezpieczeństwa. Punkty są przyznawane w oparciu o system metryk Common Vulnerability Scoring System (CVSS). Ogólna punktacja jest obliczana na podstawie wektora CVSS zawierającego różne metryki oceniających wpływ poszczególnych aspektów błędu na bezpieczeństwo systemu. W wersji CVSS 3.1 w skład wektora wchodzą takie metryki jak:
- Attack Vector (AV)
- Attack Complexity (AC)
- Privileges Required (PR)
- User Interaction (UI)
- Scope (S)
- Confidentiality (C)
- Integrity (I)
- Availability (A)

Oprócz tego baza NVD zawiera opis podatności, nazwę oprogramowania, w którym ona wystąpiła, datę zgłoszenia oraz odnośniki do powiązanych stron internetowych, m.in. wpisów na forach dyskusyjnych oraz migawek na GitHubie, w których dany błąd został naprawiony.

Blisko powiązana z systemem CVE jest Common Weakness Enumeration (CWE) – prowadzona przez społeczność lista powszechnych rodzajów podatności występujących w sprzęcie i oprogramowaniu.

Poniższy zrzut ekranu przedstawia przykładowy wpis w bazie danych NVD dostępnej pod adresem nvd.nist.gov. Dotyczy on błędu występującego w CPython – referencyjnej implementacji języka Python napisanej w C.

Po prawej stronie mamy wypisane pewne podstawowe informacje o tym CVE: numer, data publikacji w bazie danych NVD, data ostatniej modyfikacji i źródło. Jest też dostępny krótki opis podatności, w którym możemy przeczytać, że:
“Python w wersjach 3.x do 3.9.1 ma przepełnienie bufora w PyCArg_repr w _ctypes/callproc.c, co może prowadzić do zdalnego wykonania kodu w pewnych aplikacjach Pythonowych, które przyjmują liczby zmiennoprzecinkowe jako niezaufane dane wejściowe, jak zostało to zademonstrowane przez argument 1e300 do c_double.from_param. Ma to miejsce, ponieważ sprintf jest użyte w sposób niebezpieczny.”

Poniżej mamy przedstawione metryki określające wagę błędu. Widzimy, że CVE-2021-3177 otrzymało punktację 9.4 w wersji 3.1 CVSS i zostało zaklasyfikowane jako “krytyczne”. Można też przeczytać, jaką ocenę otrzymało w poszczególnych metrykach wchodzących w skład wektora CVSS.

![Zrzut ekranu ze strony [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2021-3177)](03_figures/img/cve_detail.png)

Dalej mamy listę odnośników do innych stron internetowych powiązanych z tym CVE. Są tam linki m.in. do bugtrackera Pythona, pull requesta w publicznym repozytorium CPythona na GitHubie zawierającego naprawę błędu oraz różnych list dyskusyjnych.

![Zrzut ekranu ze strony [nvd.nist.gov](https://nvd.nist.gov/vuln/detail/CVE-2021-3177)](03_figures/img/cve_references.png)

## Analiza przeżycia

W tym podrozdziale przybliżę, czym jest analiza przeżycia, i opiszę najważniejsze pojęcia z nią związane. Ta część pracy została opracowana w oparciu o [@survival-analysis-self-learning-book].

Najogólniej mówiąc, analiza przeżycia to dział statystyki zajmujący się badaniem czasu do wystąpienia jakiegoś zdarzenia. To, czym konkretnie to zdarzenie jest, zależy od rzeczywistego problemu będącego przedmiotem badania, gdyż analiza przeżycia znajduje zastosowanie w wielu różnych dziedzinach. W medycynie zdarzeniem może być na przykład śmierć pacjenta, wystąpienie określonych objawów, remisja lub nawrót choroby. W biznesie może to być rezygnacja klienta z danej usługi bądź bankructwo firmy. Z kolei w przemyśle może interesować nas przewidywany czas do awarii maszyny. Zmienna będąca wynikiem analizy jest zwykle określana jako czas przeżycia.

Do podstawowych celów analizy przeżycia należą:
- szacowanie i interpretacja funkcji przeżycia i hazardu na podstawie danych,
- porównywanie funkcji przeżycia lub hazardu,
- określanie związku zmiennych objaśniających z czasem przeżycia.

Istotnym problemem, z którym w większości przypadków trzeba się zmierzyć podczas analizy, są cenzurowane dane. Cenzurowanie ma miejsce, gdy posiadamy częściowe informacje na temat czasu przeżycia dla danej obserwacji, ale nie znamy tego czasu dokładnie.

Przykładowo załóżmy, że przedmiotem analizy są pacjenci z pewną chorobą w stanie remisji, a zdarzeniem, którego wystąpienie nas interesuje, jest nawrót choroby. Jeżeli dla danego pacjenta badanie zakończy się, gdy pacjent jest wciąż w remisji (tj. zdarzenie nie wystąpiło), mówimy, że czas przeżycia dla tego pacjenta jest cenzurowany. Wiemy, że jest on przynajmniej tak długi, jak okres, w jakim ta osoba była obserwowana, jednak nawrót mógł nastąpić po zakończeniu badania i wówczas nie mamy pełnej informacji o czasie przeżycia.

Najczęstsze powody, z jakich może wystąpić cenzurowanie, to:
1. zdarzenie nie wystąpiło u danej osoby w czasie trwania badania,
2. osoba stała się nieosiągalna,
3. osoba została wycofana z badania np. z powodu śmierci (jeśli śmierć nie była zdarzeniem podlegającym analizie przeżycia), negatywnej reakcji na lek lub współistniejącego ryzyka.

W tych przykładach rzeczywisty czas przeżycia osoby badanej staje się nieznany po prawej stronie okresu obserwacji, gdy badanie dobiega końca lub osoba wycofuje się z niego. Całkowity przedział czasowy został odcięty z prawej strony obserwowanego interwału. Takie dane nazywamy prawostronnie cenzurowanymi. Innymi słowy, dane są cenzurowane prawostronnie, gdy rzeczywisty czas przeżycia jest większy lub równy obserwowanemu czasowi przeżycia.

Dane prawostronnie cenzurowane niekoniecznie muszą być ucięte z prawej strony. Na przykład jeżeli badamy czas przeżycia pacjenta od czasu wystąpienia choroby i znamy dokładny czas śmierci, a nie znamy momentu zachorowania, to taka obserwacja również jest cenzurowana prawostronnie. Obserwowany czas przeżycia jest bowiem krótszy od rzeczywistego, mimo że nieznana część przedziału czasowego występuje po lewej stronie.

Dane mogą być również cenzurowane lewostronnie. Taka sytuacja występuje, gdy prawdziwy czas przeżycia jest mniejszy lub równy obserwowanemu czasowi przeżycia. Załóżmy na przykład, że badamy pacjentów pod kątem czasu do wystąpienia choroby. Możemy zanotować wystąpienie zdarzenia gdy pacjent uzyska pozytywny wynik testu. Nie znamy jednak dokładnie czasu, kiedy pacjent faktycznie zachorował. Czas przeżycia jest więc ucięty z lewej strony, ponieważ prawdziwy czas przeżycia kończy się wraz z wystąpieniem choroby i jest krótszy niż czas obserwacji, który kończy się przy wykonaniu testu.

Trzecim typem cenzurowania jest cenzurowanie interwałowe, które ma miejsce, gdy prawdziwy czas przeżycia mieści się w pewnym znanym, określonym przedziale czasowym. Odnosząc się do poprzedniego przykładu, załóżmy, że pacjentowi wykonano dwa testy w pewnym odstępie czasu, z których pierwszy (przeprowadzony w chwili $t_1$) dał wynik negatywny, a drugi (w chwili $t_2$) pozytywny. W takim wypadku wiemy, że zdarzenie wystąpiło między czasami przeprowadzenia obydwu testów. Obserwacja jest cenzurowana na przedziale czasowym $(t_1, t_2)$.

Zarówno cenzurowanie lewo- jak i prawostronne jest specjalnym przypadkiem cenzurowania interwałowego. Dane lewostronnie cenzurowane występują, gdy wartość $t_1$ wynosi 0, a $t_2$ jest znanym kresem górnym prawdziwego czasu przeżycia, a lewostronnie cenzurowane występują, gdy wartość $t_2$ jest nieskończona, a $t_1$ jest znanym kresem dolnym prawdziwego czasu przeżycia.

Kluczowymi miarami rozważanymi w analizie przeżycia są funkcja przeżycia, oznaczana $S(t)$ oraz funkcja hazardu, oznaczana $h(t)$.

**Definicja 1.** Niech $F(t) = P(T \leq t)$ będzie dystrybuantą zmiennej losowej $T$. Zakładamy, że $T \geq 0$ i rozważamy $F(t)$ dla $t \geq 0$. Funkcję

$$S(t) = P(T > t) = 1 - F(t)$$

nazywamy funkcją przeżycia.

Funkcja przeżycia $S(t)$ daje prawdopodobieństwo, że osoba przeżyje dłużej niż czas $t$, czyli prawdopodobieństwo, że zmienna losowa $T$ przekroczy czas $t$. Teoretycznie, gdy $t$ przyjmuje wartości od 0 do nieskończoności, funkcja przeżycia ma następujące własności:
- jest nierosnąca,

Te teoretyczne własności funkcji przeżycia zwykle nie są spełnione, gdy rysujemy wykres, używając rzeczywistych danych. Krzywa jaką uzyskujemy jest zazwyczaj funkcją schodkową. Przybliżoną funkcję przeżycia oznaczamy przez $S$.

**Definicja 2.** Jeżeli rozkład zmiennej losowej $T$ jest ciągły, to wtedy mamy:

$$S(t) = Z\int _ { t } ^ { \inf } f(u) du$$,

gdzie $f(u)$ jest gęstością zmiennej losowej $T$.

**Definicja 3.** Niech $f(t)$ będzie gęstością zmiennej losowej $T$, a $S(t)$ będzie funkcją przeżycia zmiennej $T$. Funkcją hazardu nazywamy następującą funkcję:

$$h(t) = \frac{f(t)}{S(t)}$$.

**Definicja 4.** Alternatywnie, funkcję hazardu można wyrazić wzorem:

$$h(t) = \lim _{\Delta t → 0} \frac{P(t \leq T < t + \Delta t | T \geq t)}{\Delta t}$$

Funkcja hazardu $h(t)$ daje chwilowy potencjał na jednostkę czasu, że zdarzenie zajdzie, zakładając, że osoba przetrwała do czasu $t$. W przeciwieństwie do funkcji przetrwania, która daje prawdopodobieństwo niezajścia zdarzenia, funkcja hazardu daje informacje z przeciwnej strony.

Wartości funkcji hazardu można intuicyjnie przyrównać do prędkości wskazywanej przez prędkościomierz w samochodzie. Jest ona jedynie chwilową prędkością samochodu w danym momencie i daje potencjał na to, jaki dystans samochód pokona przez godzinę, zakładając prędkość wskazywaną w danej chwili.

Należy zwrócić uwagę, że funkcja hazardu nie jest prawdopodobieństwem. W definicji 4. występuje ułamek, którego licznikiem jest prawdopodobieństwo, że czas przeżycia $T$ będzie leżał w przedziale między $t$ i $t + \Delta t$, pod warunkiem, że czas przeżycia wynosi co najmniej $t$. W mianowniku zaś jest mały interwał czasowy. Ten iloraz daje prawdopodobieństwo na jednostkę czasu, co nie jest prawdopodobieństwem, ale miarą ryzyka w chwili $t$.

Funkcja hazardu przyjmuje wartości nieujemne, ale w przeciwieństwie do funkcji przeżycia nie musi być monotoniczna. Nie ma też kresu górnego. Jak duże wartości przyjmuje zależy między innymi od używanej jednostki czasu.

## Leksery i Pygments

Lekser to program wykonujący analizę leksykalną tekstu i dzielący go na tokeny. W zastosowaniach związanych z kodem źródłowym, lekser wyodrębnia z niego poszczególne elementy języka programowania: słowa kluczowe, zmienne, operatory, literały, komentarze itd. Leksery są szeroko wykorzystywane w narzędziach programistycznych, w szczególności kompilatorach, interpreterach, linterach i kolorowaniu składni.

Pygments to otwartoźródłowe narzędzie do podświetlania składni napisane w języku Python. Obsługuje ponad 500 języków i formatów tekstu. Do wyznaczenia kolorowania kodu Pygments używa własnego leksera. Interfejs programistyczny biblioteki Pygments posiada funkcje zwracające bezpośrednie wyniki leksera, co daje dostęp do listy tokenów występujących w analizowanym kodzie źródłowym. Metoda get_tokens przyjmuje tekst jako argument i zwraca kolekcję par (tokentype, value), gdzie value to fragment tekstu, a tokentype to klasa reprezentująca, jakiego typu jest to token.

Poniższy rysunek to zrzut ekranu z demo dostępnego na oficjalnej stronie internetowej Pygments. Przedstawia on, jak Pygments dzieli przykładowy fragment kodu Pythona na tokeny. 
