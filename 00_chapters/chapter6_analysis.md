# Analiza przeżycia

W tej sekcji przeprowadzę analizę przeżycia linii kodu występujących w naprawach błędów w zbiorze HaPy-Bug, w szczególności z podziałem na kategorie linii oraz podzbiory cve, crawl i bugsinpy. Tym samym postaram się odpowiedzieć na pytanie badawcze RQ2.

W tym badaniu interesującym nas zdarzeniem z perspektywy analizy przeżycia będzie koniec istnienia danej linii kodu w pliku, a więc sytuacja, w której została ona usunięta bądź zmieniona lub plik, w którym znajdowała się linia, został usunięty albo przeniesiony. Do ustalenia momentu zdarzenia posłuży nam polecenie git blame, które przy użyciu opcji reverse, podaje informację o tym, kiedy ostatni raz dana linia pojawiła się w pliku.

Jak można się spodziewać, w naprawach błędów będą pojawiały się też linie, które od czasu wprowadzenia naprawy nie zostały w żaden sposób zmodyfikowane ani usunięte. Innymi słowy, zdarzenie dla tej linii nie wystąpiło. W danych będą więc występować obserwacje prawostronnie cenzurowane.

Narzędzie git log posłużyło mi do ustalenia czasów ostatniej modyfikacji poszczególnych plików. W ten sposób możemy uzyskać informacje o obserwacjach cenzurowanych: uznajemy, że linia kodu przetrwała, jeżeli czas jej ostatniego wystąpienia w pliku jest równy czasowi ostatniej modyfikacji pliku.

Data początkowa linii kodu jest datą migawki, z której ona pochodzi. Data końcowa to data zwracana dla tej linijki przez polecenie git blame z opcją reverse. Czas przeżycia linii kodu określamy jako czas, jaki upłynął od jej daty początkowej do daty końcowej. Jeżeli data końcowa pokrywa się z datą ostatniej modyfikacji pliku, to oznacza, że ta linia kodu przetrwała, więc jest obserwacją prawostronnie cenzurowaną.

Ponieważ interesują nas linie kodu wprowadzone w naprawach błędów, bierzemy pod uwagę tylko obserwacje, gdzie zmienna image ma wartość "afterChange".

Następne 6 rysunków przedstawia wykresy funkcji przeżycia wygenerowane przy pomocy biblioteki lifelines w Pythonie. Modelem użytym do obliczenia funkcji przeżycia był estymator Kaplana-Meiera. Pionowa oś oznacza prawdopodobieństwo przeżycia, a pozioma -- czas życia w dniach.

Wykresy \ref{cve_surv}, \ref{crawl_surv} i \ref{bip_surv} przedstawiają funkcje przeżycia dla zbiorów cve, crawl i bugsinpy odpowiednio.

Najlepsze rokowania możemy zaobserwować dla zbioru cve: na wykresie prawdopodobieństwo pomimo gwałtownego spadku na początku nie schodzi poniżej 0,3. W zbiorze crawl spadek jest większy: jeszcze przed 1000 dni prawdopodobieństwo spada do 0,3, a przy 5000 wynosi około 0,1. Wykres dla zbioru bugsinpy jest najbardziej gładki i prawdopodobieństwo nie spada poniżej 0,2.

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze cve \label{cve_surv}](03_figures/img/cve_surv.png)

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze cve z podziałem na kategorie oznaczeń \label{cve_annotation_surv}](03_figures/img/cve_annotation_surv.png)

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze crawl \label{crawl_surv}](03_figures/img/crawl_surv.png)

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze crawl z podziałem na kategorie oznaczeń \label{crawl_annotation_surv}](03_figures/img/crawl_annotation_surv.png)

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze bugsinpy \label{bip_surv}](03_figures/img/bip_surv.png)

![Wykres funkcji przeżycia zmienionych linii kodu w zbiorze bugsinpy z podziałem na kategorie oznaczeń \label{bip_annotation_surv}](03_figures/img/bip_annotation_surv.png)

Wykresy \ref{cve_annotation_surv}, \ref{crawl_annotation_surv} i \ref{bip_annotation_surv} również przedstawiają funkcje przeżycia dla trzech zbiorów, jednak z podziałem na kategorie linii.

Dla każdego zbioru przeżywalność poszczególnych rodzajów linii wygląda znacząco inaczej. W zbiorze cve wyraźnie najdłużej przeżywają linie kategorii refactoring i other, jednak dla tych pierwszych prawdopodobieństwo przeżycia 4000 dni jest bliskie 0. Podobnie wygląda wykres dla kategorii test + refactoring. U pozostałych kategorii prawdopodobieństwo jest z początku niższe, ale są też one w stanie przetrwać dłużej. W zbiorze crawl, wszystkie kategorie już na samym początku mają prawdopodobieństwo przeżycia poniżej 0,7. Ponieważ w zbiorze występują duże różnice między liczebnościami poszczególnych kategorii, niektóre krzywe są znacznie krótsze od innych. Krzywa dla kategorii test + refactoring znajduje się prawie w całości pod pozostałymi. Największe szanse przeżycia mają kategorie refactoring i bug(fix) + refactoring. Wykresy dla zbioru bugsinpy są najmniej schodkowe. Wyraźnie widać że do 2000. dnia najmniejsze prawdopodobieństwo przeżycia ma kategoria bug(fix). Najdłużej zaś przeżywają linie z testami oraz dokumentacją.

![Wykres funkcji przeżycia zmienionych linii kodu w całym zbiorze \label{all_annotation_surv}](03_figures/img/all_annotation_surv.png)

Wykres \ref{all_annotation_surv} przedstawia funkcję przeżycia z podziałem na oznaczenia dla całego zbioru danych. Kategoria test + refactoring jest jedyną, dla której krzywa spada prawie do 0. Najwyższe prawdopodobieństwo przeżycia mają linie kategorii refactoring, other i bug(fix) + refactoring.

Następnie w oparciu o powyższe wykresy, spróbowałem dla poszczególnych podzbiorów osobno oraz dla całego zbioru wyznaczyć rankingi najdłużej przeżywających kategorii linii i ocenić ich słuszność za pomocą wskaźnika zgodności. Każdej kategorii przypisałem liczbę od 1 do 7, a następnie dla takiej punktacji policzyłem wskaźnik zgodności za pomocą funkcji concordance_index z biblioteki lifelines. Wyniki przedstawia tabela \ref{concordance}.

<!-- ***************************************************** -->
<!-- ****************** start of table ******************* -->
<!-- ***************************************************** -->
Table: Wskaźnik zgodności wybranych rankingów oznaczeń linii z przeżywalnością linii. \label{concordance}

| **Zbiór**    | **bug(fix)** | **bug(fix) + refactoring** | **documentation** | **refactoring** | **test** | **test + refactoring** | **other** | **Zgodność**        |
|--------------|--------------|----------------------------|-------------------|-----------------|----------|------------------------|-----------|---------------------|
|   cve        | 3            | 5                          | 4                 | 1               | 6        | 7                      | 2         | 0.46                |
|   crawl      | 4            | 6                          | 1                 | 7               | 3        | 2                      | 5         | 0.52                |
|   bugsinpy   | 7            | 5                          | 3                 | 4               | 1        | 2                      | 6         | 0.43                |
|   wszystko   | 3            | 7                          | 2                 | 6               | 4        | 1                      | 5         | 0.56                |

<!-- ***************************************************** -->
