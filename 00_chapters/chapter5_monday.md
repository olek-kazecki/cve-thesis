# Opis zbioru i statystyki

W tym rozdziale opiszę zbiór danych “HaPy-Bug – Human Annotated Python Bug Resolution Dataset”, którego proces wytworzenia opisałem w poprzednim rozdziale, oraz wykonam eksploracyjną analizę danych. Tym samym postaram się odpowiedzieć na pytanie badawcze RQ1.

Plik collective.csv zawiera wszystkie adnotacje przypisane liniom przez poszczególnych annotatorów oraz przez skrypt. Ma on w sumie 391918 obserwacji i 11 zmiennych:

- id – identyfikator błędu w formacie *ds*_*bug*
- bundle – nazwa paczki, do której błąd został przydzielony
- file – ścieżka do pliku, z którego pochodzi linia
- fcat – kategoria tego pliku
- image – jedna z dwóch wartości: “afterChange” lub “beforeChange”. Pierwsza wartość oznacza, że obserwacja dotyczy linii kodu przed zmianą, a druga – po zmianie.
- line – numer linii w pliku
- annotation – adnotacja linii przypisana przez annotatora user
- user – identyfikator annotatora, który jest autorem annotacji
- auto – wartość binarna. Prawda oznacza, że obserwacja dotyczy adnotacji automatycznej, fałsz – manualnej.
- ds – nazwa zbioru danych: “cve”, “crawl” lub “bugsinpy”
- bug – nazwa błędu: numer CVE (w przypadku zbiorów cve i crawl) lub identyfikator błędu ze zbioru BugsInPy

Cały zbiór zawiera 793 różne błędy: 152 z podzbioru cve, 145 z podzbioru crawl i 496 z podzbioru bugsinpy. Przeanalizowano łącznie 1039 migawek.

Błędy pochodzą w sumie ze 134 projektów informatycznych: 92 z podzbioru cve, 41 z podzbioru crawl i 17 z bugsinpy. Były 2 projekty, które wystąpiły zarówno crawl i bugsinpy, 5 w cve i bugsinpy oraz 10 w cve i crawl. Jedynym projektem, który pojawił się we wszystkich trzech podzbiorach był ansible.

Poniższa tabela pokazuje projekty z największą liczbą błędów w każdym z podzbiorów cve, crawl i bugsinpy.

<!-- ***************************************************** -->
<!-- ****************** start of table ******************* -->
<!-- ***************************************************** -->
Table: projekty z największą liczbą błędów w poszczególnych podzbiorach. \label{hugh_et_al}

| Projekt  | Liczba błędów w zbiorze cve | Projekt   | Liczba błędów w zbiorze crawl | Projekt | Liczba błędów w zbiorze bugsinpy |
|----------|-----------------------------|-----------|-------------------------------|---------|----------------------------------|
| Pillow   | 12                          | django    | 43                            | pandas  | 168                              |
| cpython  | 12                          | ansible   | 22                            | keras   | 45                               |
| keystone | 8                           | Pillow    | 18                            | youtube | 43                               |
| synapse  | 6                           | salt      | 15                            | scrapy  | 40                               |
| urllib3  | 5                           | stackless | 12                            | luigi   | 33                               |
 
<!-- ***************************************************** -->

Poniższe wykresy \ref{cve_repo_counts}, \ref{crawl_repo_counts} i \ref{bugsinpy_repo_counts} pokazują, z jakich projektów pochodzi jaka liczba błędów. Zbiór cve jest najbardziej zróżnicowany pod względem zawartych w nim projektów: było ich 92 i większość miała tylko jedno CVE. Na wykresie te projekty zostały zgrupowane w słupek "inne".

![Liczba błędów z poszczególnych projektów w zbiorze cve \label{cve_repo_counts}](03_figures/img/cve_repo_counts.png)

![Liczba błędów z poszczególnych projektów w zbiorze crawl \label{crawl_repo_counts}](03_figures/img/crawl_repo_counts.png)

![Liczba błędów z poszczególnych projektów w zbiorze bugsinpy \label{bugsinpy_repo_counts}](03_figures/img/bugsinpy_repo_counts.png)

Na wykresach skrzynkowych \ref{commit_lines} przedstawione są liczby linii zmienionych w pojedynczej migawce dla każdego z podzbiorów. Od lewej: cve, crawl i bugsinpy. Jak widać, migawki w zbiorze bugsinpy są znacznie krótsze niż w pozostałych zbiorach.

![Wykresy liczby linii zmienionych w każdej migawce dla zbiorów cve (lewy), crawl (środkowy), bugsinpy (prawy) \label{commit_lines}](03_figures/img/commit_lines.png)

![Wykres liczby plików danej kategorii dla każdego zbioru. \label{project_structure} @HaPy-Bug](03_figures/img/project_structure.png)

Najczęściej występującą kategorią pliku w całym zbiorze jest programming, a zaraz za nią – test. Najrzadszą kategorią jest markup.

Zarówno w zbiorze cve, jak i bugsinpy, najwięcej plików ma kategorię programming. Na drugim miejscu jest kategoria test, podobnie jak w całym zbiorze danych ogólnie.

Inaczej sytuacja wygląda w zbiorze crawl. Tam najwięcej było plików dokumentacji. Wyjątkowo dużo jest w nim też plików kategorii project: dwa razy więcej niż w cve i bugsinpy razem wziętych.

Najwięcej linii w zbiorze danych stanowią linie z plików kategorii test: jest ich ponad 50%. Na drugim miejscu jest kategoria programming (>30%) i documentation (10%). Linie z plików kategorii data, markup i other stanowią mniej niż 1% wszystkich linii.

Zgodnie z oczekiwaniami, w plikach kategorii test większość linii stanowią linie oznaczone jako test (87%). Podobnie sytuacja wygląda w plikach data: 83% to linie z testami. Co również jest spodziewane, w plikach dokumentacji najwięcej linii było z adnotacją documentation (98%). W plikach kategorii project, programming i markup, dominowały linie z adnotacją bugfix: odpowiednio 58%, 69% i 81%. Najbardziej zróżnicowaną kategorią plików było other, gdzie linie były stosunkowo równomiernie rozłożone między bugfix (23%), documentation (44%) i other (29%). Refaktoryzacja najczęściej pojawiała się w plikach kategorii markup i programming: 10% i 8% odpowiednio.

![Wykres przedstawiający udział plików danej kategorii w całym zbiorze (po lewej) oraz udział linii danej kategorii w poszczególnych typach plików (po prawej). \label{fcat_annotations} @HaPy-Bug](03_figures/img/fcat_annotations.svg)

![](03_figures/img/legend_fcat_annotations.svg)

Oznaczenia linii ręcznie przypisywane przez użytkowników odznaczają się dużą zgodnością z oznaczeniami przypisanymi automatycznie przez skrypt. W każdym ze zbiorów było ponad 70% linii, przy których trzech annotatorów nie zmieniło oznaczenia automatycznego.

W zbiorze bugsinpy ten odsetek wyniósł ponad 80%. Jest to zapewne spowodowane tym, że BugsInPy jest ręcznie selekcjonowanym zbiorem, gdzie zadbano o to, by błędy były wyizolowane. Większość błędów zawierało zmiany tylko w jednym pliku z kodem źródłowym, pliku dokumentacją i pliku z testami. Sama naprawa błędu często miała tylko kilka linijek. Dzięki prostej i stosunkowo jednolitej strukturze zbioru bugsinpy skrypt miał dużą skuteczność w automatycznym oznaczaniu linii. 

![Wykres zgodności automatycznych oznaczeń linii z manualnymi. 2xU != A (3xU != A) -- dla danej linii dwie (odp. trzy) ręczne adnotacje są różne od tej przypisanej przez skrypt. 2xU == A (3xU == A) -- dla danej linii dwie (odp. trzy) ręczne adnotacje są zgodne z tą przypisaną przez skrypt. \label{automatic_vs_users} [@HaPy-Bug]](03_figures/img/automatic_vs_users.svg)

Wykresy słupkowe \ref{fcat_structure_cve}, \ref{fcat_structure_crawl} i \ref{fcat_structure_bip} pokazują liczbę linii poszczególnych kategorii w podziale na kategorie plików i na podzbiory bugsinpy, crawl i cve. Wszystkie trzy podzbiory mają podobny rozkład oznaczeń.

Widać jednak, że na przykład bugsinpy ma więcej linii oznaczonych jako test, co jest spodziewane, biorąc pod uwagę wcześniejsze wyniki wskazujące, że w tym podzbiorze było najwięcej plików kategorii test. W zbiorze crawl z kolei jest dużo więcej linii oznaczonych jako documentation, co również zgadza się z poprzednim wykresem, gdzie widać, że jest w nim dużo plików z dokumentacją. Natomiast zbiór cve ma w porównaniu z pozostałymi dwoma podzbiorami wyjątkowo dużo linii kategorii refactoring.

![Wykres liczby linii każdej kategorii w poszczególnych kategoriach plików w zbiorze cve. \label{fcat_structure_cve} [@HaPy-Bug]](03_figures/img/fcat_structure_cve.png)

![Wykres liczby linii każdej kategorii w poszczególnych kategoriach plików w zbiorze crawl. \label{fcat_structure_crawl} [@HaPy-Bug]](03_figures/img/fcat_structure_crawl.png)

![Wykres liczby linii każdej kategorii w poszczególnych kategoriach plików w zbiorze bugsinpy. \label{fcat_structure_bip} [@HaPy-Bug]](03_figures/img/fcat_structure_bip.png)

Wykres \ref{distribution_of_labels_in_fixes} przedstawia, jaki procent wszystkich linii w pojedynczym błędzie stanowiły linie danej kategorii. Można zauważyć, że najbardziej zróżnicowane są kategorie bug(fix) oraz test. Choć linie oznaczone jako test ogólnie stanowiły w poszczególnych błędach większy procent linii niż linie oznaczone jako bug(fix), to w przypadku obydwu kategorii zdarzały się zarówno błędy, gdzie takie linie zajmowały prawie 100% wszystkich linii, jak i takie, gdzie nie było ich prawie wcale.

Zauważalnie mniejsze procenty są w kategorii documentation, jednak i tutaj jest dość duży rozrzut. Zarówno w bugsinpy jak i crawl zdarzały się naprawy błędów, gdzie dokumentacja stanowiła ponad 80% zmian.

Znacznie rzadsze były kategorie z refaktoryzacją: bug(fix)+refactoring, refactoring i test+refactoring. Chociaż zdarzały się pojedyncze błędy, gdzie taka kategoria stanowiła większą część naprawy, w większości przypadków takie linijki nie przekraczały 30%.

![Wykres przedstawiający procentowy udział każdej kategorii linii w poszczególnych błędach. \label{distribution_of_labels_in_fixes} [@HaPy-Bug]](03_figures/img/distribution_of_labels_in_fixes.svg)

Wykres \ref{flow} to tzw. wykres Sankeya. Ten typ wykresu służy do graficznego przedstawiania przepływu między stanami. W tym przypadku został użyty do zobrazowania, na jakie oznaczenia annotatorzy zmieniali oznaczenia automatycznie przypisane przez skrypt.

Po lewej stronie mamy oznaczenia automatyczne, a po prawej – ręczne. Po lewej stronie są wymienione tylko trzy kategorie, ponieważ tylko te były używane przez skrypt, i, jak można zauważyć, zdecydowana większość automatycznych adnotacji pozostaje bez zmian, co jest zgodne z poprzednimi wynikami ukazującymi wysoką zgodność automatycznych oznaczeń z manualnymi.

Najczęściej występującą zmianą z jednej kategorii na drugą jest zmiana z bug(fix) oraz z test na documentation. Jest to w dużej mierze spowodowane tym, że skrypt często ma problem z rozpoznawaniem wielolinijkowych komentarzy w kodzie, wobec czego wiele linii z takich komentarzy nie było wstępnie oznaczonych jako dokumentacja.

Drugim częstym kierunkiem przepływu jest kategoria refactoring. To oznaczenie najczęściej było przypisywane liniom automatycznie oznaczonym jako bug(fix).

![Wykres przepływu oznaczeń linii. \label{flow} [@HaPy-Bug]](03_figures/img/flow.png)

Wykresy \ref{typical_bip}, \ref{typical_CVE} i \ref{typical_crawl} dla każdego z podzbiorów, cve, crawl i bugsinpy, przedstawiają liczby linii każdej z kategorii w poszczególnych błędach.

Pierwsze dwa wykresy dotyczą zbiorów bugsinpy i cve. Obydwa mają podobne rozkłady. W obydwu dominuje kategoria test, a za nią kolejno bug(fix) i documentation.

Różnica między test i pozostałymi kategoriami jest jednak znacznie większa w zbiorze cve, gdzie liczba adnotacji w niektórych przypadkach dochodziła prawie do 7 tysięcy. Różnica jest również w liczbach adnotacji w ogóle. W zbiorze bugsinpy liczba oznaczeń nie przekraczała 600, a większość błędów miała ich poniżej 100. W zbiorze cve .

Najbardziej wyróżnia się wykres zbioru crawl. Są w nim mniejsze różnice między liczebnością poszczególnych kategorii linii, ale też jest on jedynym podzbiorem, w którym wystąpiły obserwacje odstające.

![Wykres liczby linii każdej z kategorii w poszczególnych błędach w zbiorze bugsinpy. \label{typical_bip} [@HaPy-Bug]](03_figures/img/typical_bip.svg)

![Wykres liczby linii każdej z kategorii w poszczególnych błędach w zbiorze cve. \label{typical_CVE} [@HaPy-Bug]](03_figures/img/typical_CVE.svg)

![Wykres liczby linii każdej z kategorii w poszczególnych błędach w zbiorze crawl. \label{typical_crawl} [@HaPy-Bug]](03_figures/img/typical_crawl.svg)

Wykresy \ref{mean_annotations_per_commit_crawl} i \ref{mean_annotations_per_commit_bip} przedstawiają średnią liczbę adnotacji każdej kategorii przypadającą na migawkę w poszczególnych projektach dla zbiorów crawl i bugsinpy.

![Wykres średniej liczby adnotacji każdej z kategorii na migawkę w poszczególnych projektach w zbiorze crawl. \label{mean_annotations_per_commit_crawl}](03_figures/img/mean_annotations_per_commit_crawl.png)

![Wykres średniej liczby adnotacji każdej z kategorii na migawkę w poszczególnych projektach w zbiorze bugsinpy. \label{mean_annotations_per_commit_bip}](03_figures/img/mean_annotations_per_commit_bip.png)
